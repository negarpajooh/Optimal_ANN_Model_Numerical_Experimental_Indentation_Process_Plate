function [Y,Xf,Af] = myNeuralNetworkFunction(X,~,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 16-Nov-2020 10:49:00.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = Qx5 matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = Qx3 matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [1215.13336489934;11.9568597596715;277.045928955078;25882.0484204484;-20.3725480044733];
x1_step1.gain = [5.04738077349817e-05;0.0561979893892336;0.00177170699952136;4.36295772732315e-05;0.100781354319116];
x1_step1.ymin = -1;

% Layer 1
b1 = [-3.5807367158909668703;1.0173624167560402221;-2.5100489677790962517;-0.13653427149976352095;0.9018286981109350231;0.6732033226732251352;-0.77811983472868273548;1.5445696359825062949;-1.4386673071702784643;2.8152235829223895003];
IW1_1 = [1.4434006668996366418 -0.63201456810434242239 -1.081524791931009144 -1.1535740117662620641 -0.62846191851893062896;-1.2246039062161233613 0.64615600073533241421 -0.26547511401155948763 -0.92985195901674166929 0.63884190398912443776;-1.1369718775392327892 0.9923375239774059331 0.38199708840904145202 2.9415679934243152971 -1.869810045799483289;-0.0099996046995872722718 -0.36574857921513981296 1.3947338288067598899 -0.40582048607533260931 -1.097844834371377587;-0.28805822008810422208 0.55080312738715964116 0.28942046850858821339 0.25373204823245076867 0.29112529645798668199;1.3031164757211857186 1.0645211226233730617 0.94961085069605455367 -0.11458389979661963431 0.70241213077308539692;0.47138909716110100057 0.69160770766149026745 -1.1208586197075451896 0.44308988248154695944 0.49823410194496342562;1.4408773064321935831 0.54430892427252708377 -0.85058853494989827837 0.29773679927329976813 0.47469254514001796297;-0.79299174125762406096 0.79627656727473694609 1.6012997430242605912 -0.24052359875811274437 0.51111183659753267605;-0.058285974234984105902 -1.6839487662619097019 -1.5664623480921546772 -0.9299388361784662882 1.144927860063616798];

% Layer 2
b2 = [0.93059541786378141559;-0.50763594981380422144;-0.50748772302712963356];
LW2_1 = [0.31312989116966072345 -0.28509832458254236176 -0.16380842175695622953 0.21492881885815495746 0.98997101855225466682 0.1246866470992261805 2.0857597909525167346 0.84416485463265267253 1.0616121464581027567 0.020787748458601110202;-1.0261839699641750467 0.029536982289412955227 -0.14703734388547315404 0.79971564971365760588 -0.37436824298067983285 0.022173769982336569151 0.14926149445179814901 0.08544037832994724746 0.53424807364810822374 -0.12754793903250444265;0.19797846527579193721 -0.49463169531802436696 -0.2518591216441877223 0.049230602220546551551 0.18634115778213616865 0.90829245732810215408 0.7181799723376796063 -0.080529089653500557366 -0.50238966305496468578 -0.85661592035100619924];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [9.61076405574243e-05;0.00666666666666667;4.76190476190476];
y1_step1.xoffset = [19050;50;0.02];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
    X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},1); % samples/series
else
    Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    X{1,ts} = X{1,ts}';
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
    Y{1,ts} = Y{1,ts}';
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
    Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
